<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>B√†i ki·ªÉm tra tr·∫Øc nghi·ªám Chi nh√°nh C·∫ßn Th∆° II</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-touch-fullscreen" content="yes">
  <link rel="apple-touch-icon" href="logo.png">
  <link rel="apple-touch-icon" sizes="180x180" href="logo.png">
  <!-- Main CSS -->
  <link rel="stylesheet" href="styles.css">
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <!-- Config file -->
  <script src="config.js"></script>
  <script src="indexeddb-storage.js"></script>
  <script src="storage-wrapper.js"></script>
  <script src="quiz-storage-helper.js"></script>
  <!-- Excel export library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
  .modal {
    position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.25); display: flex; align-items: center; justify-content: center;
    z-index: 9999;
  }
  .modal.hidden { display: none; }
  .modal-content {
    background: #fff; border-radius: 10px; padding: 24px; box-shadow: 0 8px 32px rgba(128,0,32,0.13);
    max-width: 340px; text-align: center;
  }
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }
  .modal-header h3 { 
    margin: 0; 
    color: #800020; 
    flex: 1;
  }
  .close-btn {
    background: none;
    border: none;
    font-size: 28px;
    color: #999;
    cursor: pointer;
    padding: 0;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
    font-weight: bold;
    line-height: 1;
  }
  .close-btn:hover {
    background: #f0f0f0;
    color: #333;
    transform: scale(1.1);
  }
  .modal-actions { 
    margin-top: 22px; 
    display: flex; 
    gap: 12px; 
    justify-content: center; 
    flex-wrap: wrap;
  }
  .modal-actions .btn { 
    min-width: 120px; 
    display: flex;
    align-items: center;
    gap: 6px;
    justify-content: center;
  }
  
  /* Question Navigation Sidebar */
  .question-sidebar {
    position: fixed;
    top: 0;
    right: -300px;
    width: 300px;
    height: 100vh;
    background: white;
    border-left: 2px solid #e0e0e0;
    box-shadow: -4px 0 12px rgba(0,0,0,0.1);
    z-index: 1000;
    transition: right 0.3s ease;
    overflow-y: auto;
  }
  
  .question-sidebar.open {
    right: 0;
  }
  
  .sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    background: #f8f9fa;
    border-bottom: 1px solid #e0e0e0;
    position: sticky;
    top: 0;
    z-index: 10;
  }
  
  .sidebar-header h3 {
    margin: 0;
    font-size: 16px;
    color: #800020;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .question-list {
    padding: 16px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(35px, 1fr));
    gap: 6px;
    justify-items: center;
  }
  
  .question-item {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 35px;
    height: 35px;
    margin: 6px auto;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid #e0e0e0;
    position: relative;
    font-weight: bold;
    font-size: 12px;
    background: #f5f5f5;
    color: #666;
  }
  
  .question-item.pending {
    background: #f5f5f5;
    border-color: #e0e0e0;
    color: #666;
  }
  
  .question-item:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }
  
  .question-item.current {
    background: #e3f2fd;
    border-color: #2196f3;
    box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
    color: #2196f3;
  }
  
  .question-item.answered {
    background: #e8f5e8;
    border-color: #4caf50;
    color: #2e7d32;
  }
  
  .question-item.flagged {
    background: #fff3e0;
    border-color: #ff9800;
    color: #f57c00;
  }
  
  .question-item.answered.flagged {
    background: linear-gradient(135deg, #e8f5e8 0%, #fff3e0 100%);
    border-color: #ff9800;
    color: #f57c00;
  }
  
  .question-item.correct {
    background: #e8f5e8;
    border-color: #4caf50;
    color: #2e7d32;
  }
  
  .question-item.incorrect {
    background: #ffebee;
    border-color: #f44336;
    color: #c62828;
  }
  
  .question-item.correct.flagged {
    background: linear-gradient(135deg, #e8f5e8 0%, #fff3e0 100%);
    border-color: #4caf50;
    color: #2e7d32;
  }
  
  .question-item.incorrect.flagged {
    background: linear-gradient(135deg, #ffebee 0%, #fff3e0 100%);
    border-color: #f44336;
    color: #c62828;
  }
  
  
  .status-icon {
    font-size: 16px;
  }
  
  .status-answered {
    color: #4caf50;
  }
  
  .status-correct {
    color: #4caf50;
  }
  
  .status-incorrect {
    color: #f44336;
  }
  
  .status-flagged {
    color: #ff9800;
  }
  
  .status-pending {
    color: #9e9e9e;
  }
  
  /* Result Panel Styles */
  .result-panel {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    overflow-y: auto;
  }
  
  .result-container {
    background: white;
    margin: 50px auto;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    max-width: 600px;
    width: 90%;
  }
  
  .result-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }
  
  .result-header h2 {
    margin: 0;
    color: #333;
    font-size: 24px;
    flex: 1;
  }
  
  .score-display {
    text-align: center;
    margin-bottom: 30px;
  }
  
  .score {
    font-size: 48px;
    font-weight: bold;
    color: #2196f3;
  }
  
  .score span {
    font-size: 24px;
    color: #666;
  }
  
  .percentage {
    font-size: 18px;
    color: #666;
    margin-top: 10px;
  }
  
  .result-form {
    margin-bottom: 30px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
  }
  
  .form-group {
    margin-bottom: 20px;
  }
  
  .form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: #333;
  }
  
  .form-group input {
    width: 100%;
    padding: 12px;
    border: 2px solid #e0e0e0;
    border-radius: 6px;
    font-size: 14px;
    transition: border-color 0.3s ease;
  }
  
  .form-group input:focus {
    outline: none;
    border-color: #2196f3;
  }
  
  .result-actions {
    margin-top: 2rem;
  }
  
  .result-actions-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
    max-width: 600px;
    margin: 0 auto;
  }
  
  .result-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 14px 20px;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.3s ease;
    min-height: 52px;
    font-size: 0.95rem;
  }
  
  .result-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
  }
  
  .result-btn.primary {
    background: var(--primary-color);
    color: white;
    border: 2px solid var(--primary-color);
  }
  
  .result-btn.primary:hover {
    background: var(--primary-dark);
    border-color: var(--primary-dark);
  }
  
  /* Header styling */
  .header-top {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }
  
  .home-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 16px;
    font-size: 14px;
    white-space: nowrap;
  }
  
  .home-btn .material-icons {
    font-size: 18px;
  }
  
  /* Sidebar toggle button */
  .sidebar-toggle-btn {
    position: fixed;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
    background: #800020;
    color: white;
    border: none;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(128, 0, 32, 0.3);
    z-index: 999;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .sidebar-toggle-btn:hover {
    background: #a00028;
    transform: translateY(-50%) scale(1.1);
  }
  
  .sidebar-toggle-btn.hidden {
    display: none;
  }
  
  /* Mobile-specific quiz enhancements */
  @media (max-width: 768px) {
    .question-sidebar {
      width: 280px;
      right: -280px;
    }
 
    
    .sidebar-toggle-btn {
      right: 10px;
      width: 45px;
      height: 45px;
    }
    
    .question-item {
      width: 30px;
      height: 30px;
      font-size: 10px;
    }
    
    .question-list {
      grid-template-columns: repeat(auto-fit, minmax(30px, 1fr));
      gap: 4px;
    }
    
    .result-container {
      margin: 20px auto;
      padding: 20px;
      max-width: 95vw;
    }
    
    .result-container h2 {
      font-size: 20px;
    }
    
    .score {
      font-size: 36px;
    }
    
    .score span {
      font-size: 18px;
    }
    
    .result-form {
      padding: 15px;
    }
    
    .result-actions-grid {
      grid-template-columns: 1fr;
      gap: 0.75rem;
      max-width: 100%;
    }
    
    .result-btn {
      width: 100%;
      font-size: 0.9rem;
      padding: 12px 16px;
      min-height: 48px;
    }
    
    .header-top {
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
    }
    
    .home-btn {
      align-self: flex-end;
      padding: 6px 12px;
      font-size: 13px;
    }
    
    .home-btn span {
      display: none;
    }
    
    .modal-content {
      max-width: 95vw;
      margin: 20px;
      padding: 24px 20px;
    }
    
    .modal-actions {
      flex-direction: column;
      gap: 12px;
    }
    
    .modal-actions .btn {
      width: 100%;
      min-width: auto;
    }
    
    .quiz-meta {
      flex-direction: column !important;
      align-items: flex-start !important;
      gap: 12px !important;
      margin-top: 16px !important;
    }
    
    #question-counter {
      font-size: 16px !important;
      font-weight: 600 !important;
    }
    
    #timer {
      font-size: 16px !important;
      padding: 8px 12px !important;
      border-radius: 8px !important;
      background: #f8f9fa !important;
    }
    
    .btn-icon {
      width: 44px !important;
      height: 44px !important;
      border-radius: 50% !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
    
    /* Mobile Footer Optimization */
    footer {
      padding: 8px 10px 6px !important;
      margin-top: 15px !important;
      font-size: 11px !important;
    }
    
    footer .max-width-1200px {
      gap: 8px !important;
      margin-bottom: 6px !important;
    }
    
    footer .flex-1 {
      min-width: 100% !important;
      margin-bottom: 6px !important;
    }
    
    footer .logo {
      width: 24px !important;
      height: 24px !important;
    }
    
    footer h3 {
      font-size: 0.7em !important;
      line-height: 1.2 !important;
    }
    
    footer p {
      font-size: 0.65em !important;
      line-height: 1.2 !important;
    }
    
    footer .contact-section {
      min-width: 100% !important;
      padding: 8px !important;
    }
    
    footer .contact-section h4 {
      font-size: 0.75em !important;
      margin-bottom: 4px !important;
    }
    
    footer .contact-item {
      margin-bottom: 3px !important;
      padding: 2px 4px !important;
    }
    
    footer .contact-item span {
      font-size: 0.65em !important;
    }
    
    footer .copyright {
      padding-top: 6px !important;
      margin-top: 6px !important;
      font-size: 0.6em !important;
      line-height: 1.2 !important;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <div class="header-top">
      <div class="logo">
        <img src="logo.png" alt="Logo" id="logo-img" onerror="console.error('Logo load failed:', this.src);">
        <div class="logo-text">
          <h1><b>H·ªÜ TH·ªêNG TR·∫ÆC NGHI·ªÜM CHI NH√ÅNH C·∫¶N TH∆† II</b></h1>
          <p id="topic-name"></p>
        </div>
        </div>
        <a href="index.html" class="btn btn-outline home-btn" title="V·ªÅ trang ch·ªß">
          <i class="material-icons">home</i>
          <span>Trang ch·ªß</span>
        </a>
      </div>
      <div class="quiz-progress">
        <div id="progress-bar"></div>
      </div>
      <div class="quiz-meta" style="display:flex; justify-content:space-between; align-items:center; margin-top:6px;">
        <div id="question-counter">C√¢u 1/10</div>
        <div style="display:flex; align-items:center; gap:8px;">
          <div id="timer" class="timer" style="font-weight:600; color:#800020"></div>
          <button id="pause-btn" class="btn-icon" style="display:none" title="T·∫°m d·ª´ng/ti·∫øp t·ª•c">
            <i class="material-icons">pause</i>
          </button>
        </div>
      </div>
    </header>    
    <div class="content">
      <div id="question-container">
        <div class="question-header">
          <div id="question" class="question"></div>
          <div class="question-meta">
            <button id="show-flagged-btn" class="btn btn-outline" title="Xem c√°c c√¢u ƒë√£ ƒë√°nh d·∫•u" style="display: none;">
              <i class="material-icons">bookmark</i>
              <span id="flag-count">0</span>
            </button>
          </div>
        </div>
        <div id="answers" class="answers"></div>
        <div id="explanation" class="explanation"></div>
      </div>

      <div class="quiz-controls">
        <button id="prev-btn" class="btn btn-primary">
  <i class="material-icons">navigate_before</i> C√¢u tr∆∞·ªõc
</button>
        <div class="quiz-actions">
          <button id="flag-btn" class="btn btn-flag">
            <i class="material-icons">bookmark_border</i> ƒê√°nh d·∫•u
          </button>
          <button id="submit-quiz-btn" class="btn btn-danger">
            <i class="material-icons">send</i> N·ªôp b√†i
          </button>
        </div>
        <button id="next-btn" class="btn btn-primary">
          C√¢u ti·∫øp <i class="material-icons">navigate_next</i>
        </button>
      </div>

      <!-- Question Navigation Sidebar -->
      <div id="question-sidebar" class="question-sidebar">
        <div class="sidebar-header">
          <h3><i class="material-icons">list</i> Danh s√°ch c√¢u h·ªèi</h3>
          <button id="toggle-sidebar" class="btn btn-icon">
            <i class="material-icons">chevron_right</i>
          </button>
        </div>
        <div id="question-list" class="question-list">
          <!-- Question list will be inserted here -->
        </div>
      </div>


      <div id="result" class="result-panel"></div>
    </div>
    
    <!-- Sidebar Toggle Button -->
    <button id="sidebar-toggle-btn" class="sidebar-toggle-btn" title="M·ªü danh s√°ch c√¢u h·ªèi">
      <i class="material-icons">list</i>
    </button>
  
<!-- Modal h·ªèi ti·∫øp t·ª•c session -->
  <div id="session-modal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
      <h3>Ti·∫øp t·ª•c b√†i ki·ªÉm tra?</h3>
        <button id="close-session-modal" class="close-btn">&times;</button>
      </div>
        <p>B·∫°n ƒë√£ c√≥ m·ªôt phi√™n l√†m b√†i tr∆∞·ªõc ƒë√≥.<br>B·∫°n mu·ªën ti·∫øp t·ª•c hay b·∫Øt ƒë·∫ßu phi√™n m·ªõi?</p>
        <div class="modal-actions">
          <button id="resume-btn" class="btn btn-primary">Ti·∫øp t·ª•c phi√™n c≈©</button>
          <button id="new-session-btn" class="btn btn-outline">B·∫Øt ƒë·∫ßu m·ªõi</button>
        <a href="index.html" class="btn btn-outline">
          <i class="material-icons">home</i> V·ªÅ trang ch·ªß
        </a>
        </div>
    </div>
  </div>

<!-- Modal nh·∫≠p th√¥ng tin ng∆∞·ªùi d√πng tr∆∞·ªõc khi n·ªôp b√†i -->
  <div id="user-info-modal" class="modal hidden">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h3>K·∫øt qu·∫£ v√† th√¥ng tin</h3>
        <button id="close-user-info-modal" class="close-btn">&times;</button>
      </div>
      
      <!-- Hi·ªÉn th·ªã ƒëi·ªÉm s·ªë -->
      <div id="score-preview" style="text-align: center; margin-bottom: 20px; padding: 16px; background: #f8f9fa; border-radius: 8px;">
        <div style="font-size: 24px; font-weight: bold; color: #2196f3; margin-bottom: 8px;">
          <span id="preview-correct">0</span>/<span id="preview-total">0</span>
        </div>
        <div style="font-size: 18px; color: #666;">
          <span id="preview-percentage">0</span>%
        </div>
      </div>
      
      <p style="margin-bottom: 16px;">Vui l√≤ng nh·∫≠p th√¥ng tin c·ªßa b·∫°n (t√πy ch·ªçn):</p>
      <form id="user-info-form">
        <div class="form-group">
          <label for="user-fullname">H·ªç t√™n</label>
          <input type="text" id="user-fullname" name="fullname" placeholder="Nh·∫≠p h·ªç t√™n c·ªßa b·∫°n">
        </div>
        <div class="form-group">
          <label for="user-branch">ƒê∆°n v·ªã</label>
          <input type="text" id="user-branch" name="branch" placeholder="Nh·∫≠p ƒë∆°n v·ªã">
        </div>
      </form>
      <div class="modal-actions">
        <button id="cancel-submit-btn" class="btn btn-outline">H·ªßy</button>
        <button id="confirm-submit-btn" class="btn btn-primary">X√°c nh·∫≠n n·ªôp b√†i</button>
      </div>
    </div>
  </div>
  <script>
    // üîÑ Auto-cleanup: X√≥a localStorage c≈© khi load trang (quiz progress ƒë√£ chuy·ªÉn sang IndexedDB)
    (function() {
      const keysToKeep = ['admin_credentials', 'admin_authenticated', 'deleted_review_topics', 'deleted_review_topics_map'];
      const keysToRemove = [];
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && !keysToKeep.includes(key)) {
          keysToRemove.push(key);
        }
      }
      
      if (keysToRemove.length > 0) {
        keysToRemove.forEach(key => localStorage.removeItem(key));
      }
    })();
    
    // üîÑ AUTO-MIGRATION: Copy data t·ª´ localStorage sang IndexedDB
    (async function autoMigrateToIndexedDB() {
      try {
        // Wait for IndexedDB to be ready
        if (window.db && window.db.ready) {
          await window.db.ready;
          
          // Check if we have data in localStorage that needs migration
          const hasLocalStats = localStorage.getItem('quiz_statistics');
          const hasLocalWrongAnswers = localStorage.getItem('wrong_answers');
          
          if (hasLocalStats || hasLocalWrongAnswers) {
            console.log('üì¶ Found data in localStorage, starting migration to IndexedDB...');
            
            // Perform migration
            const migrated = await window.db.migrateFromLocalStorage();
            
            if (migrated.statistics > 0 || migrated.wrongAnswers > 0) {
              console.log('‚úÖ Migration completed:', migrated);
              
              // Clear migrated data from localStorage to save space
              if (migrated.statistics > 0) {
                localStorage.removeItem('quiz_statistics');
                console.log('üóëÔ∏è Removed quiz_statistics from localStorage');
              }
              if (migrated.wrongAnswers > 0) {
                localStorage.removeItem('wrong_answers');
                console.log('üóëÔ∏è Removed wrong_answers from localStorage');
              }
            }
          } else {
            console.log('‚úÖ No data to migrate from localStorage');
          }
        }
      } catch (error) {
        console.error('‚ùå Auto-migration error:', error);
      }
    })();
    
    // DOM Elements - will be initialized when DOM is ready
    let questionEl, answersEl, progressEl, questionCounterEl, prevBtn, nextBtn, submitBtn, flagBtn;
    let showFlaggedBtn, flagCountEl;
    let explanationEl, resultArea, timerEl, pauseBtn;
    let questionSidebar, questionList, toggleSidebarBtn, sidebarToggleBtn;
    let sessionModal, resumeBtn, newSessionBtn, closeSessionModal;
    let userInfoModal, userInfoForm, userFullnameInput, userBranchInput, cancelSubmitBtn, confirmSubmitBtn, closeUserInfoModal;

    // Quiz state
    let topicId = null;
    let topics = [];
    let topic = null;
    let questions = [];
    let currentQuestionIndex = 0;
    let userAnswers = [];
    let quizSubmitted = false;
    let timerInterval = null;
    let endTimeMs = null;
    let isPaused = false;

    // Safe localStorage functions
    function safeSetItem(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch (e) {
        console.warn('localStorage.setItem failed for key:', key, e);
        return false;
      }
    }

    function safeGetItem(key) {
      try {
        return localStorage.getItem(key);
      } catch (e) {
        console.warn('localStorage.getItem failed for key:', key, e);
        return null;
      }
    }

    function safeRemoveItem(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (e) {
        console.warn('localStorage.removeItem failed for key:', key, e);
        return false;
      }
    }

    // Initialize DOM elements
    function initDOMElements() {
      questionEl = document.getElementById('question');
      answersEl = document.getElementById('answers');
      progressEl = document.getElementById('progress-bar');
      questionCounterEl = document.getElementById('question-counter');
      prevBtn = document.getElementById('prev-btn');
      nextBtn = document.getElementById('next-btn');
      submitBtn = document.getElementById('submit-quiz-btn');
      flagBtn = document.getElementById('flag-btn');
      showFlaggedBtn = document.getElementById('show-flagged-btn');
      flagCountEl = document.getElementById('flag-count');
      explanationEl = document.getElementById('explanation');
      resultArea = document.getElementById('result');
      timerEl = document.getElementById('timer');
      pauseBtn = document.getElementById('pause-btn');
      questionSidebar = document.getElementById('question-sidebar');
      questionList = document.getElementById('question-list');
      toggleSidebarBtn = document.getElementById('toggle-sidebar');
      sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
      sessionModal = document.getElementById('session-modal');
      resumeBtn = document.getElementById('resume-btn');
      newSessionBtn = document.getElementById('new-session-btn');
      closeSessionModal = document.getElementById('close-session-modal');
      userInfoModal = document.getElementById('user-info-modal');
      userInfoForm = document.getElementById('user-info-form');
      userFullnameInput = document.getElementById('user-fullname');
      userBranchInput = document.getElementById('user-branch');
      cancelSubmitBtn = document.getElementById('cancel-submit-btn');
      confirmSubmitBtn = document.getElementById('confirm-submit-btn');
      closeUserInfoModal = document.getElementById('close-user-info-modal');
      
      // Debug logging
      console.log('DOM elements initialized:');
      console.log('questionEl:', questionEl);
      console.log('answersEl:', answersEl);
      console.log('questionCounterEl:', questionCounterEl);
    }

function scrollToQuestion() {
  // ∆Øu ti√™n ph·∫ßn t·ª≠ ƒëang hi·ªÉn th·ªã n·ªôi dung c√¢u h·ªèi
  const el = document.getElementById('question') 
          || document.querySelector('.question-text') 
          || document.getElementById('question-container');

  if (!el) return;

  // Cho ph√©p focus t·∫°m ƒë·ªÉ .focus() kh√¥ng l·ªói tr√™n m·ªôt s·ªë tr√¨nh duy·ªát
  if (!el.hasAttribute('tabindex')) el.setAttribute('tabindex', '-1');

  // Cu·ªôn m∆∞·ª£t l√™n v√πng c√¢u h·ªèi v√† ƒë·∫∑t focus (kh√¥ng cu·ªôn l·∫ßn 2)
  requestAnimationFrame(() => {
    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    el.focus({ preventScroll: true });
  });
}

    // Shuffle helpers
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Helpers for multi-correct handling
    function getCorrectLabels(question) {
      if (!question) return [];
      const labels = (question.optionLabels || []).slice(); // e.g., ["A","B","C","D"]
      const pickLabel = (token) => {
        if (!token) return null;
        const t = String(token).replace(/[\u00A0\s]+/g, '').trim();
        if (!t) return null;
        // Support combined like "A/1" or "c/3": split by '/'
        const parts = t.split('/').map(p => p.trim()).filter(Boolean);
        let letter = null;
        let number = null;
        parts.forEach(p => {
          const mNum = p.match(/^\d+$/);
          if (mNum) number = parseInt(p, 10);
          const mLet = p.match(/^[A-Za-z]$/);
          if (mLet) letter = mLet[0].toUpperCase();
        });
        if (letter && labels.includes(letter)) return letter;
        if (number && number >= 1 && number <= labels.length) return labels[number - 1];
        // If token is just a letter or number (no slash)
        const tUpper = t.toUpperCase();
        if (/^[A-D]$/.test(tUpper)) return tUpper;
        const asNum = parseInt(t, 10);
        if (!Number.isNaN(asNum) && asNum >= 1 && asNum <= labels.length) return labels[asNum - 1];
        return null;
      };

      const ans = question.answer;
      let tokens = [];
      if (Array.isArray(ans)) tokens = ans;
      else if (typeof ans === 'string') {
        // If cell contains descriptive text then ';' followed by codes, take part after last ';'
        let s = ans;
        if (s.includes(';')) s = s.substring(s.lastIndexOf(';') + 1);
        // Normalize separators: comma, fullwidth comma, ideographic comma, semicolon
        const seps = /[\,\uFF0CÔºõ;„ÄÅ]/g;
        tokens = s.split(seps).map(x => x).filter(Boolean);
      } else return [];
      const mapped = tokens.map(pickLabel).filter(Boolean);
      // De-duplicate
      return Array.from(new Set(mapped));
    }

    function isMulti(question) {
      const labels = getCorrectLabels(question);
      return labels.length > 1;
    }

    function setsEqual(a, b) {
      if (a.length !== b.length) return false;
      const sa = new Set(a);
      for (const x of b) if (!sa.has(x)) return false;
      return true;
    }

    function shuffleOptions(question) {
      const letterPool = ["A", "B", "C", "D"];
      const pairs = (question.optionLabels || []).map((label, idx) => ({
        label: label,
        text: question.options[idx]
      }));
      // determine correct option texts before shuffling (support multi)
      const originalLabels = (question.optionLabels || []).slice();
      const correctLabels = getCorrectLabels(question);
      const correctTexts = correctLabels
        .map(lbl => {
          const idx = originalLabels.indexOf(lbl);
          return idx >= 0 ? question.options[idx] : null;
        })
        .filter(t => t !== null);
      shuffleArray(pairs);
      // reassign labels A..D in new order and options accordingly
      question.optionLabels = pairs.map((_, idx) => letterPool[idx]);
      question.options = pairs.map(p => p.text);
      // set new correct label(s) by matching text
      const newCorrectLabels = [];
      correctTexts.forEach(ct => {
        const newIndex = question.options.findIndex(t => t === ct);
        if (newIndex >= 0) newCorrectLabels.push(question.optionLabels[newIndex]);
      });
      if (newCorrectLabels.length > 1) question.answer = newCorrectLabels;
      else if (newCorrectLabels.length === 1) question.answer = newCorrectLabels[0];
    }

    function shuffleQuestionsAndOptions() {
      // shuffle options within each question first
      questions.forEach(q => shuffleOptions(q));
      // then shuffle question order
      shuffleArray(questions);
    }

    // Initialize quiz
    async function initQuiz() {
  topicId = getTopicId();
  
  // Check for old session using IndexedDB
  const oldSession = await quizStorage.getProgress(topicId);

  if (oldSession) {
    try {
      const sessionData = JSON.parse(oldSession);
      // N·∫øu session c≈© ƒë√£ n·ªôp b√†i th√¨ kh√¥ng hi·ªÉn th·ªã modal, b·∫Øt ƒë·∫ßu session m·ªõi
      if (sessionData.quizSubmitted) {
        await quizStorage.deleteProgress(topicId);
        await quizStorage.deleteTimerEnd(topicId);
        await quizStorage.deleteExamQuestions(topicId);
        await continueInitQuiz();
        return;
      }
    } catch (e) {
      // N·∫øu kh√¥ng parse ƒë∆∞·ª£c th√¨ x√≥a session c≈© v√† b·∫Øt ƒë·∫ßu m·ªõi
      console.error('Error parsing session:', e);
      await quizStorage.deleteProgress(topicId);
      await continueInitQuiz();
      return;
    }
    
    // Hi·ªÉn th·ªã modal h·ªèi ng∆∞·ªùi d√πng (cho c·∫£ chuy√™n ƒë·ªÅ v√† b√†i thi)
    const modal = document.getElementById('session-modal');
    modal.classList.remove('hidden');
    return new Promise(resolve => {
      document.getElementById('resume-btn').onclick = async () => {
        modal.classList.add('hidden');
        resolve();
      };
      document.getElementById('new-session-btn').onclick = async () => {
        // Delete all session data from IndexedDB
        await quizStorage.deleteProgress(topicId);
        await quizStorage.deleteTimerEnd(topicId);
        await quizStorage.deleteExamQuestions(topicId);
        modal.classList.add('hidden');
        resolve();
      };
    }).then(() => continueInitQuiz());
  } else {
    await continueInitQuiz();
  }
}

async function continueInitQuiz() {
  // Initialize DOM elements first
  initDOMElements();
  
  // Check localStorage quota and clear old data if needed
  if (!safeSetItem('test_quota', 'test')) {
    console.warn('localStorage quota exceeded, clearing ALL old data...');
    clearAllCache();
  } else {
    safeRemoveItem('test_quota');
  }
  
  // DON'T clear ALL cache here! It will delete locally created topics!
  // Only clear if there's actually a quota issue
  // clearAllCache();
  
  // Load topics from IndexedDB
  const topicsStr = await quizStorage.getTopics();
  topics = JSON.parse(topicsStr || '[]');
  
  // Filter out deleted review topics
  const blacklist = await window.db.getConfig('deleted_review_topics') || [];
  if (blacklist.length > 0) {
    const beforeFilter = topics.length;
    topics = topics.filter(t => !blacklist.includes(t.id));
    console.log('üóëÔ∏è Filtered blacklist. Before:', beforeFilter, 'After:', topics.length, 'Blacklist:', blacklist);
  }
  
  console.log('Topics from IndexedDB:', topics.length);
  console.log('Looking for topicId:', topicId);
  
  topic = topics.find(t => t.id === topicId);
  console.log('Topic found in localStorage:', topic ? topic.name : 'Not found');

  if (!topic) {
    console.log('Topic not found in localStorage, fetching from remote...');
    try {
      const url = new URL('./topics.json', location.href);
      url.searchParams.set('v', Date.now());
      const resp = await fetch(url, { cache: 'no-store' });
      if (resp.ok) {
        const remoteTopics = await resp.json();
        console.log('Remote topics loaded:', remoteTopics.length);
        if (Array.isArray(remoteTopics) && remoteTopics.length > 0) {
          // IMPORTANT: MERGE local topics with remote topics (don't override!)
          // Keep locally created topics (e.g., wrong_answers_quiz_...)
          const localOnlyTopics = topics.filter(t => 
            t.createdFrom === 'wrong_answers' || t.id.startsWith('wrong_answers_quiz_')
          );
          const remoteTopicIds = new Set(remoteTopics.map(t => t.id));
          const uniqueLocalTopics = localOnlyTopics.filter(t => !remoteTopicIds.has(t.id));
          let mergedTopics = [...remoteTopics, ...uniqueLocalTopics];
          
          // Filter out deleted review topics from merged list
          if (blacklist.length > 0) {
            const beforeBlacklist = mergedTopics.length;
            mergedTopics = mergedTopics.filter(t => !blacklist.includes(t.id));
            console.log('üóëÔ∏è Filtered blacklist from merged. Before:', beforeBlacklist, 'After:', mergedTopics.length);
          }
          
          console.log('Merging: Remote=' + remoteTopics.length + ', Local=' + uniqueLocalTopics.length + ', Total=' + mergedTopics.length);
          
          // Save to IndexedDB
          const saved = await quizStorage.saveTopics(JSON.stringify(mergedTopics));
          if (saved) {
            topics = mergedTopics;
            topic = topics.find(t => t.id === topicId);
            console.log('Topic found after merge:', topic ? topic.name : 'Not found');
          } else {
            console.warn('Failed to save topics to IndexedDB');
            // Clear old cache and try again
            await quizStorage.clearOldProgress(topicId);
            const savedRetry = await quizStorage.saveTopics(JSON.stringify(mergedTopics));
            if (savedRetry) {
              topics = mergedTopics;
              topic = topics.find(t => t.id === topicId);
              console.log('Topic found after clearing cache and remote fetch:', topic ? topic.name : 'Not found');
            } else {
              console.error('Still failed to save topics after clearing cache');
              // Use merged topics directly without saving
              topics = mergedTopics;
              topic = topics.find(t => t.id === topicId);
              console.log('Using topics directly from remote (not cached):', topic ? topic.name : 'Not found');
            }
          }
        }
      } else {
        console.error('Failed to fetch remote topics:', resp.status);
      }
    } catch (e) {
      console.error('Error fetching remote topics:', e);
    }
  }

  if (!topic) {
    showError('Kh√¥ng t√¨m th·∫•y chuy√™n ƒë·ªÅ!');
    return;
  }

  document.getElementById('topic-name').textContent = topic.name;
  
  // Debug logging
  console.log('Topic found:', topic);
  console.log('Topic name:', topic.name);
  console.log('Topic isExam:', topic.isExam);
  console.log('Topic examConfig:', topic.examConfig);
  
  // For exams, assemble questions per attempt using current topics based on examConfig
  if (topic.isExam === true && topic.examConfig && Array.isArray(topic.examConfig.distribution)) {
    try {
      questions = await getOrCreateExamSessionQuestions(topic);
    } catch (e) {
      console.error('Error getting exam session questions, using fallback:', e);
      questions = topic.questions || [];
    }
  } else {
    questions = topic.questions || [];
  }

  console.log('Questions loaded:', questions.length);
  console.log('First question:', questions[0]);

  if (questions.length === 0) {
    showError('Chuy√™n ƒë·ªÅ n√†y ch∆∞a c√≥ c√¢u h·ªèi!');
    return;
  }

  // Shuffle questions and answers n·∫øu kh√¥ng c√≥ saved progress
  const hasSavedProgress = !!(await quizStorage.getProgress(topicId));
  if (!hasSavedProgress) {
    shuffleQuestionsAndOptions();
  }

  // Initialize user answers
  userAnswers = questions.map((q, index) => ({
    answer: null,
    correct: null,
    flagged: false,
    explanationShown: false
  }));

  console.log('User answers initialized:', userAnswers.length);
  console.log('First user answer:', userAnswers[0]);

  // Load saved progress n·∫øu c√≥
  await loadProgress();
  
  // Ensure flag button is hidden initially if no flagged questions
  const flagCount = userAnswers.filter(a => a.flagged).length;
  if (showFlaggedBtn && flagCountEl) {
    showFlaggedBtn.style.display = flagCount > 0 ? 'flex' : 'none';
    flagCountEl.textContent = flagCount > 0 ? flagCount : '';
  }

  // Initialize event listeners
  initEventListeners();

  // Show first question
  showQuestion(currentQuestionIndex);
  
  // Initialize question list
  updateQuestionList();

  // Initialize countdown timer (use topic duration or ask user)
  const effectiveMinutes = getEffectiveDurationMinutes();
  if (effectiveMinutes > 0) {
    startOrResumeTimer(effectiveMinutes);
  } else if (timerEl) {
    timerEl.style.display = 'none';
  }

  // Setup Pause/Resume if allowed
  if (pauseBtn) {
    if (topic.allowPause) {
      pauseBtn.style.display = 'inline-flex';
      pauseBtn.addEventListener('click', togglePauseResume);
      // restore paused state if any
      const pausedSaved = await quizStorage.getTimerPaused(topicId);
      if (pausedSaved === 'true') {
        isPaused = true;
        const remainingStr = await quizStorage.getTimerRemaining(topicId);
        const remain = parseInt(remainingStr || '0', 10);
        if (remain > 0) {
          endTimeMs = Date.now() + remain; // keep a reference
          updateTimerDisplay(remain);
        }
        setPausedUI(true);
      }
    } else {
      pauseBtn.style.display = 'none';
    }
  }
}

    async function loadProgress() {
      const savedProgress = await quizStorage.getProgress(topicId);
      if (savedProgress) {
        try {
          const progress = JSON.parse(savedProgress);
          if (progress.answers) userAnswers = progress.answers;
          if (progress.currentIndex !== undefined) currentQuestionIndex = progress.currentIndex;
          // Only load quizSubmitted if it's explicitly false (not submitted)
          // If quiz was submitted, we should start fresh
          if (progress.quizSubmitted === false) {
            quizSubmitted = false;
          } else {
            // If quiz was submitted, clear the progress and start fresh
            quizSubmitted = false;
            await quizStorage.deleteProgress(topicId);
            // Reset userAnswers to fresh state
            userAnswers = questions.map((q, index) => ({
              answer: null,
              correct: null,
              flagged: false,
              explanationShown: false
            }));
            currentQuestionIndex = 0;
          }
        } catch (e) {
          console.error('Error loading progress:', e);
        }
      }
    }

    async function saveProgress() {
      const progress = {
        answers: userAnswers,
        currentIndex: currentQuestionIndex,
        quizSubmitted: quizSubmitted,
        timestamp: new Date().toISOString()
      };
      const saved = await quizStorage.saveProgress(topicId, JSON.stringify(progress));
      if (!saved) {
        console.warn('Failed to save progress to IndexedDB');
        // Try to clear old data and save again
        await quizStorage.clearOldProgress(topicId);
        await quizStorage.saveProgress(topicId, JSON.stringify(progress));
      }
    }

    // ===== Exam assembly per attempt =====
    async function getOrCreateExamSessionQuestions(examTopic) {
      // Try to get cached questions first
      const cached = await quizStorage.getExamQuestions(examTopic.id);
      if (cached) {
        try {
          const parsed = JSON.parse(cached);
          if (Array.isArray(parsed) && parsed.length > 0) {
            console.log('Using cached exam questions:', parsed.length);
            return parsed;
          }
        } catch (e) {
          console.warn('Error parsing cached exam questions:', e);
        }
      }
      
      // Build new questions
      const built = buildExamQuestions(examTopic);
      if (Array.isArray(built) && built.length > 0) {
        // Try to cache, but don't fail if we can't
        const saved = await quizStorage.saveExamQuestions(examTopic.id, JSON.stringify(built));
        if (saved) {
          console.log('Cached exam questions successfully');
        } else {
          console.log('Continuing without caching exam questions');
        }
      }
      return built;
    }

    function clearOldCache() {
      try {
        // Clear old exam question caches (keep only current topic)
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('quiz_exam_questions_') && key !== `quiz_exam_questions_${topicId}`) {
            keysToRemove.push(key);
          }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        console.log('Cleared old exam question caches:', keysToRemove.length);
        
        // Clear old progress data (keep only current topic)
        const progressKeysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('quiz_progress_') && key !== `quiz_progress_${topicId}`) {
            progressKeysToRemove.push(key);
          }
        }
        progressKeysToRemove.forEach(key => localStorage.removeItem(key));
        console.log('Cleared old progress data:', progressKeysToRemove.length);
        
        // Clear old timer data (keep only current topic)
        const timerKeysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && (key.startsWith('quiz_timer_') || key.startsWith('quiz_custom_duration_')) && !key.includes(topicId)) {
            timerKeysToRemove.push(key);
          }
        }
        timerKeysToRemove.forEach(key => localStorage.removeItem(key));
        console.log('Cleared old timer data:', timerKeysToRemove.length);
        
      } catch (e) {
        console.error('Error clearing old cache:', e);
      }
    }

    function clearAllCache() {
      try {
        console.log('Clearing ALL localStorage data...');
        // Clear ALL quiz-related data except current topic
        const allKeysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && (
            key.startsWith('quiz_') || 
            key.startsWith('wrong_answers') ||
            key.startsWith('quiz_statistics')
          ) && !key.includes(topicId)) {
            allKeysToRemove.push(key);
          }
        }
        allKeysToRemove.forEach(key => localStorage.removeItem(key));
        console.log('Cleared ALL quiz cache data:', allKeysToRemove.length);
        
        // If still not enough space, clear even more
        if (allKeysToRemove.length > 0) {
          try {
            localStorage.setItem('test_quota_after_clear', 'test');
            localStorage.removeItem('test_quota_after_clear');
            console.log('localStorage quota is now available');
          } catch (e) {
            console.warn('Still quota exceeded after clearing all quiz data');
            // Clear even more data if needed
            const moreKeysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key !== 'quiz_topics' && !key.includes(topicId)) {
                moreKeysToRemove.push(key);
              }
            }
            moreKeysToRemove.forEach(key => localStorage.removeItem(key));
            console.log('Cleared additional data:', moreKeysToRemove.length);
          }
        }
        
      } catch (e) {
        console.error('Error clearing all cache:', e);
      }
    }

    function buildExamQuestions(examTopic) {
      try {
        const allTopics = JSON.parse(safeGetItem('quiz_topics') || '[]');
        const dist = examTopic.examConfig?.distribution || [];
        const total = parseInt(examTopic.examConfig?.total || 0, 10);
        if (!Array.isArray(dist) || !Number.isFinite(total) || total <= 0) {
          console.log('Using fallback questions from examTopic');
          return examTopic.questions || [];
        }

        // Calculate allocation similar to admin builder
        const withCalc = dist.map(d => ({ id: d.id, percent: d.percent, exact: (total * d.percent) / 100 }));
        let allocated = withCalc.map(x => ({ id: x.id, count: Math.floor(x.exact), frac: x.exact - Math.floor(x.exact) }));
        let assigned = allocated.reduce((s, a) => s + a.count, 0);
        let remain = total - assigned;
        if (remain > 0) {
          allocated.sort((a, b) => b.frac - a.frac);
          for (let i = 0; i < allocated.length && remain > 0; i++) { allocated[i].count += 1; remain--; }
        }

        // Sample per topic
        const combined = [];
        for (const a of allocated) {
          const t = allTopics.find(t => t.id === a.id);
          if (!t || !Array.isArray(t.questions)) {
            // Missing topic; fallback to existing exam questions
            console.log('Missing topic, using fallback questions');
            return examTopic.questions || [];
          }
          if (a.count > t.questions.length) {
            // Not enough questions; fallback
            console.log('Not enough questions, using fallback questions');
            return examTopic.questions || [];
          }
          const copy = t.questions.slice();
          // shuffle
          for (let i = copy.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [copy[i], copy[j]] = [copy[j], copy[i]]; }
          combined.push(...copy.slice(0, a.count));
        }
        // final shuffle
        for (let i = combined.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [combined[i], combined[j]] = [combined[j], combined[i]]; }
        console.log('Built exam questions successfully:', combined.length);
        return combined;
      } catch (e) {
        console.error('Error building exam questions, using fallback:', e);
        return examTopic.questions || [];
      }
    }

    // Determine duration: Only exams have/ask for duration.
    // Prefer topic.durationMinutes; if missing and this IS an exam, ask once and cache.
    function getEffectiveDurationMinutes() {
      if (typeof topic.durationMinutes === 'number' && topic.durationMinutes > 0) {
        return topic.durationMinutes;
      }
      // If not an exam, do not ask for time; no timer for normal topics.
      if (topic.isExam !== true) return 0;
      try {
        const key = `quiz_custom_duration_${topicId}`;
        const saved = localStorage.getItem(key);
        let minutes = saved ? parseInt(saved, 10) : NaN;
        if (!Number.isFinite(minutes) || minutes <= 0) {
          const input = prompt('Nh·∫≠p th·ªùi gian l√†m b√†i (ph√∫t):', '30');
          if (input === null) return 0; // user canceled
          minutes = parseInt(input, 10);
          if (!Number.isFinite(minutes) || minutes <= 0) return 0;
          localStorage.setItem(key, String(minutes));
        }
        return minutes;
      } catch (e) {
        return 0;
      }
    }

    // ===== Timer Logic =====
    function formatTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const h = Math.floor(totalSec / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      const pad = (n) => n.toString().padStart(2,'0');
      return h > 0 ? `${pad(h)}:${pad(m)}:${pad(s)}` : `${pad(m)}:${pad(s)}`;
    }

    function updateTimerDisplay(remainMs){
      if (!timerEl) return;
      timerEl.textContent = formatTime(remainMs);
      timerEl.classList.remove('warning','danger');
      if (remainMs <= 60 * 1000) {
        timerEl.classList.add('danger');
      } else if (remainMs <= 120 * 1000) {
        timerEl.classList.add('warning');
      }
    }

    function updateTimer() {
      if (!endTimeMs || !timerEl) return;
      const remain = endTimeMs - Date.now();
      updateTimerDisplay(remain);
      if (remain <= 0) {
        clearInterval(timerInterval);
        timerInterval = null;
        if (!quizSubmitted) {
          alert('H·∫øt th·ªùi gian. B√†i s·∫Ω ƒë∆∞·ª£c n·ªôp t·ª± ƒë·ªông.');
          submitQuiz();
        }
      }
    }

    async function startOrResumeTimer(durationMinutes) {
      const saved = await quizStorage.getTimerEnd(topicId);
      const pausedSaved = await quizStorage.getTimerPaused(topicId);
      
      if (saved) {
        endTimeMs = parseInt(saved, 10);
      } else {
        endTimeMs = Date.now() + durationMinutes * 60 * 1000;
        await quizStorage.saveTimerEnd(topicId, String(endTimeMs));
      }
      
      if (timerEl) timerEl.style.display = 'block';
      
      if (pausedSaved === 'true') {
        // display remaining time without ticking
        isPaused = true;
        const remainingStr = await quizStorage.getTimerRemaining(topicId);
        const remain = parseInt(remainingStr || '0', 10);
        updateTimerDisplay(remain > 0 ? remain : (endTimeMs - Date.now()));
        setPausedUI(true);
      } else {
        updateTimer();
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 1000);
      }
    }

    function togglePauseResume(){
      if (isPaused) {
        resumeTimer();
      } else {
        pauseTimer();
      }
    }

    async function pauseTimer(){
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
      const remain = Math.max(0, endTimeMs - Date.now());
      await quizStorage.saveTimerPaused(topicId, 'true');
      await quizStorage.saveTimerRemaining(topicId, String(remain));
      isPaused = true;
      setPausedUI(true);
      updateTimerDisplay(remain);
    }

    async function resumeTimer(){
      const remainingStr = await quizStorage.getTimerRemaining(topicId);
      const remain = parseInt(remainingStr || '0', 10);
      const base = isNaN(remain) || remain <= 0 ? (endTimeMs - Date.now()) : remain;
      endTimeMs = Date.now() + Math.max(0, base);
      await quizStorage.saveTimerEnd(topicId, String(endTimeMs));
      await quizStorage.saveTimerRemaining(topicId, '0'); // Clear remaining
      await quizStorage.saveTimerPaused(topicId, 'false');
      isPaused = false;
      setPausedUI(false);
      updateTimer();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 1000);
    }

    function setPausedUI(paused){
      if (!pauseBtn) return;
      if (paused) {
        pauseBtn.innerHTML = '<i class="material-icons">play_arrow</i>';
        pauseBtn.title = 'Ti·∫øp t·ª•c';
        // disable interactions while paused
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        submitBtn.disabled = true;
      } else {
        pauseBtn.innerHTML = '<i class="material-icons">pause</i>';
        pauseBtn.title = 'T·∫°m d·ª´ng';
        prevBtn.disabled = currentQuestionIndex === 0;
        nextBtn.disabled = currentQuestionIndex === questions.length - 1;
        submitBtn.disabled = false;
      }
    }

    function showQuestion(index) {
      if (index < 0 || index >= questions.length) return;
      
      currentQuestionIndex = index;
      const question = questions[index];
      const userAnswer = userAnswers[index];
      
      // Debug logging
      console.log('showQuestion called with index:', index);
      console.log('question:', question);
      console.log('questionEl:', questionEl);
      console.log('answersEl:', answersEl);
      
      // Update question number display (single source)
      if (questionCounterEl) {
        questionCounterEl.textContent = `C√¢u ${index + 1}/${questions.length}`;
      }
      
      // Update question text - with safety check
      if (questionEl && question) {
        questionEl.textContent = question.question;
        // Add or update hint under question about single/multi select
        let hintEl = document.getElementById('question-hint');
        if (!hintEl) {
          hintEl = document.createElement('div');
          hintEl.id = 'question-hint';
          hintEl.className = 'question-hint';
          questionEl.insertAdjacentElement('afterend', hintEl);
        }
        const multi = isMulti(question);
        const multiHint = multi ? '(C√¢u h·ªèi ch·ªçn nhi·ªÅu ƒë√°p √°n)' : '(C√¢u h·ªèi ch·ªçn 1 ƒë√°p √°n)';
        const ua = userAnswers[index] || {};
        const answeredHint = Array.isArray(ua.answer) ? ua.answer.length > 0 : ua.answer != null;
        const statusHtml = answeredHint
          ? (ua.correct ? '<span class="status-correct">ƒê√É CH·ªåN: ƒê√öNG</span>' : '<span class="status-incorrect">ƒê√É CH·ªåN: SAI</span>')
          : '';
        hintEl.innerHTML = `${multiHint} ${statusHtml ? '‚Ä¢ ' + statusHtml : ''}`;
      } else {
        console.error('questionEl or question is null:', { questionEl, question });
      }
      
      // Update answers
      if (answersEl) {
        answersEl.innerHTML = '';
        console.log('Question optionLabels:', question.optionLabels);
        console.log('Question options:', question.options);
        
        if (question.optionLabels && question.options) {
          question.optionLabels.forEach((label, i) => {
            const answer = question.options[i];
            const answerEl = document.createElement('div');
            const multi = isMulti(question);
            const correctLabels = getCorrectLabels(question);
            const isSelected = multi
              ? Array.isArray(userAnswer.answer) && userAnswer.answer.includes(label)
              : userAnswer.answer === label;
            const isCorrect = correctLabels.includes(label);
            const hasAnswer = Array.isArray(userAnswer.answer) ? userAnswer.answer.length > 0 : userAnswer.answer != null;
            const reveal = quizSubmitted || hasAnswer;
            
            let answerClass = 'answer';
            if (isSelected) answerClass += ' selected';
            if (reveal) {
              // Coloring rules:
              // - After submit: show all correct options
              // - Before submit:
              //    * Multi-choice: only color selected-correct as green
              //    * Single-choice: show the correct option as green even if not selected
              let markCorrect = false;
              if (quizSubmitted) markCorrect = isCorrect;
              else if (multi) markCorrect = isSelected && isCorrect;
              else markCorrect = isCorrect; // single-choice
              if (markCorrect) answerClass += ' correct';
              if (isSelected && !isCorrect) answerClass += ' incorrect';
            }
            
            answerEl.className = answerClass;
            const inputType = multi ? 'checkbox' : 'radio';
            const checkedAttr = isSelected ? 'checked' : '';
            const disabledAttr = quizSubmitted ? 'disabled' : '';
            const inputName = `answer-group-q-${index}`; // unique per question
            answerEl.innerHTML = `
              <input type="${inputType}" class="answer-input" name="${inputName}" ${checkedAttr} ${disabledAttr} />
              <span class="option">${label}.</span>
              <span class="text">${answer}</span>
            `;
            
            if (!quizSubmitted) {
              const inputEl = answerEl.querySelector('.answer-input');
              answerEl.onclick = (e) => {
                // When clicking the row, also toggle the input for immediate visual feedback
                if (multi) {
                  if (inputEl) inputEl.checked = !inputEl.checked;
                  window.toggleMultiAnswer(label);
                } else {
                  // For radio, uncheck others and check this one
                  if (inputEl) {
                    const group = document.querySelectorAll(`input.answer-input[name='${inputName}']`);
                    group.forEach(inp => { inp.checked = false; });
                    inputEl.checked = true;
                  }
                  window.selectAnswer(label);
                }
              };
              if (inputEl) {
                inputEl.addEventListener('change', (e) => {
                  e.stopPropagation();
                  if (multi) window.toggleMultiAnswer(label);
                  else window.selectAnswer(label);
                });
              }
            }
            
            answersEl.appendChild(answerEl);
          });
        } else {
          console.error('Missing optionLabels or options:', { optionLabels: question.optionLabels, options: question.options });
        }
      } else {
        console.error('answersEl is null');
      }

      // Update flag button
      updateFlagButton();
      
      // Show explanation if available and shown before
      if (userAnswer.explanationShown && question.explain) {
        showExplanation(question.explain);
      } else {
        explanationEl.style.display = 'none';
      }
      
      // Update navigation
      updateNavigation();
      updateProgress();
// ... cu·ªëi showQuestion(index):
if (window.forceFocusButtonOnce) {
  // B·ªè qua focus v·ªÅ c√¢u h·ªèi cho l·∫ßn render n√†y
  window.forceFocusButtonOnce = false;
} else if (window.suppressFocusUntilMs && Date.now() < window.suppressFocusUntilMs) {
  // B·ªè qua focus v·ªÅ c√¢u h·ªèi n·∫øu ƒëang trong kho·∫£ng th·ªùi gian suppress sau khi ch·ªçn ƒë√°p √°n
} else {
  scrollToQuestion();
}
updateNextBtnStatus();


    }

    function updateFlagButton() {
      if (!flagBtn || !userAnswers || currentQuestionIndex < 0 || currentQuestionIndex >= userAnswers.length) {
        return;
      }
      
      const isFlagged = userAnswers[currentQuestionIndex].flagged;
      flagBtn.innerHTML = `
        <i class="material-icons">${isFlagged ? 'bookmark' : 'bookmark_border'}</i>
        ${isFlagged ? 'B·ªè ƒë√°nh d·∫•u' : 'ƒê√°nh d·∫•u'}
      `;
      flagBtn.classList.toggle('active', isFlagged);
      
      // Update flag count and show/hide button
      const flagCount = userAnswers.filter(a => a.flagged).length;
      if (flagCountEl) {
      flagCountEl.textContent = flagCount > 0 ? flagCount : '';
      }
      if (showFlaggedBtn) {
      showFlaggedBtn.style.display = flagCount > 0 ? 'flex' : 'none';
      }
      
      // Update question list
      updateQuestionList();
    }

    function updateQuestionList() {
      if (!questionList || !userAnswers || !questions) return;
      
      const questionItems = userAnswers.map((userAnswer, index) => {
        const isCurrent = index === currentQuestionIndex;
        const isAnswered = Array.isArray(userAnswer.answer) ? userAnswer.answer.length > 0 : userAnswer.answer !== null;
        const isCorrect = userAnswer.correct === true;
        const isIncorrect = userAnswer.correct === false;
        const isFlagged = userAnswer.flagged;
        
        let statusIcon = '';
        let statusClass = '';
        let statusText = '';
        
        if (isAnswered && isFlagged) {
          if (isCorrect) {
            statusIcon = '<i class="material-icons status-icon status-correct">check_circle</i><i class="material-icons status-icon status-flagged">bookmark</i>';
            statusText = 'ƒê√∫ng + ƒê√°nh d·∫•u';
            statusClass = 'correct flagged';
          } else if (isIncorrect) {
            statusIcon = '<i class="material-icons status-icon status-incorrect">cancel</i><i class="material-icons status-icon status-flagged">bookmark</i>';
            statusText = 'Sai + ƒê√°nh d·∫•u';
            statusClass = 'incorrect flagged';
          } else {
            statusIcon = '<i class="material-icons status-icon status-answered">check_circle</i><i class="material-icons status-icon status-flagged">bookmark</i>';
            statusText = 'ƒê√£ tr·∫£ l·ªùi + ƒê√°nh d·∫•u';
            statusClass = 'answered flagged';
          }
        } else if (isAnswered) {
          if (isCorrect) {
            statusIcon = '<i class="material-icons status-icon status-correct">check_circle</i>';
            statusText = 'ƒê√∫ng';
            statusClass = 'correct';
          } else if (isIncorrect) {
            statusIcon = '<i class="material-icons status-icon status-incorrect">cancel</i>';
            statusText = 'Sai';
            statusClass = 'incorrect';
          } else {
            statusIcon = '<i class="material-icons status-icon status-answered">check_circle</i>';
            statusText = 'ƒê√£ tr·∫£ l·ªùi';
            statusClass = 'answered';
          }
        } else if (isFlagged) {
          statusIcon = '<i class="material-icons status-icon status-flagged">bookmark</i>';
          statusText = 'ƒê√°nh d·∫•u';
          statusClass = 'flagged';
        } else {
          statusIcon = '<i class="material-icons status-icon status-pending">radio_button_unchecked</i>';
          statusText = 'Ch∆∞a tr·∫£ l·ªùi';
          statusClass = 'pending';
        }
        
        return `
          <div class="question-item ${statusClass} ${isCurrent ? 'current' : ''}" data-index="${index}" title="${statusText}">
            ${index + 1}
          </div>
        `;
      }).join('');
      
      questionList.innerHTML = questionItems;
      
      // Add click handlers
      questionList.querySelectorAll('.question-item').forEach(item => {
        item.addEventListener('click', () => {
          const index = parseInt(item.dataset.index);
          if (index >= 0 && index < questions.length) {
            currentQuestionIndex = index;
            showQuestion(index);
            // Close sidebar on mobile
            if (window.innerWidth <= 768) {
              questionSidebar.classList.remove('open');
              sidebarToggleBtn.classList.remove('hidden');
            }
          }
        });
      });
    }

    function updateNavigation() {
      prevBtn.disabled = currentQuestionIndex === 0;
      nextBtn.disabled = currentQuestionIndex === questions.length - 1;
      
      // Submit is always available
      submitBtn.style.display = 'inline-flex';
      
      // Hide next on last question
      if (currentQuestionIndex === questions.length - 1) {
        nextBtn.style.display = 'none';
      } else {
        nextBtn.style.display = 'inline-flex';
      }
    }

    function updateProgress() {
      const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
      progressEl.style.width = `${progress}%`;
    }

    function showExplanation(text) {
      explanationEl.innerHTML = `
        <h4><i class="material-icons">info</i> Gi·∫£i th√≠ch</h4>
        <p>${text}</p>
      `;
      explanationEl.style.display = 'block';
    }

    // Single-answer handler
    window.selectAnswer = function(answer) {
      if (quizSubmitted || isPaused) return;
      const userAnswer = userAnswers[currentQuestionIndex];
      const question = questions[currentQuestionIndex];
      const correctLabels = getCorrectLabels(question);
      userAnswer.answer = answer;
      userAnswer.correct = correctLabels.length === 1 && answer === correctLabels[0];
      if (question.explain) {
        showExplanation(question.explain);
        userAnswer.explanationShown = true;
      }
      // Tr√°nh focus quay l·∫°i c√¢u h·ªèi trong m·ªôt kho·∫£ng ng·∫Øn sau khi c·∫≠p nh·∫≠t l·ª±a ch·ªçn
      window.suppressFocusUntilMs = Date.now() + 1200;
      // √âp b·ªè qua focus c√¢u h·ªèi cho l·∫ßn render k·∫ø ti·∫øp v√† chuy·ªÉn focus sang n√∫t ƒëi·ªÅu h∆∞·ªõng
      window.forceFocusButtonOnce = true;
      showQuestion(currentQuestionIndex);
      saveProgress();
      updateNextBtnStatus();
      // Sau khi ch·ªçn ƒë√°p √°n, focus sang n√∫t C√¢u ti·∫øp ho·∫∑c N·ªôp b√†i n·∫øu l√† c√¢u cu·ªëi
      // Delay ƒë·ªÉ ƒë·∫£m b·∫£o DOM ƒë√£ c·∫≠p nh·∫≠t xong
      setTimeout(() => focusNextOrSubmit(), 100);
    }

    // Multi-answer handler (checkboxes)
    window.toggleMultiAnswer = function(label) {
      if (quizSubmitted || isPaused) return;
      const userAnswer = userAnswers[currentQuestionIndex];
      if (!Array.isArray(userAnswer.answer)) userAnswer.answer = [];
      const idx = userAnswer.answer.indexOf(label);
      if (idx >= 0) userAnswer.answer.splice(idx, 1); else userAnswer.answer.push(label);
      const question = questions[currentQuestionIndex];
      const correctLabels = getCorrectLabels(question);
      userAnswer.correct = setsEqual([...userAnswer.answer].sort(), [...correctLabels].sort());
      if (question.explain) {
        showExplanation(question.explain);
        userAnswer.explanationShown = true;
      }
      // Tr√°nh focus quay l·∫°i c√¢u h·ªèi trong m·ªôt kho·∫£ng ng·∫Øn sau khi c·∫≠p nh·∫≠t l·ª±a ch·ªçn
      window.suppressFocusUntilMs = Date.now() + 400;
      // √âp b·ªè qua focus c√¢u h·ªèi cho l·∫ßn render n√†y
      window.forceFocusButtonOnce = true;
      showQuestion(currentQuestionIndex);
      saveProgress();
      updateNextBtnStatus();
      // Ch·ªâ focus khi s·ªë l∆∞·ª£ng l·ª±a ch·ªçn ƒë√£ ch·ªçn b·∫±ng v·ªõi s·ªë ƒë√°p √°n c·∫ßn ch·ªçn c·ªßa c√¢u h·ªèi
      try {
        const neededCount = Array.isArray(correctLabels) ? correctLabels.length : 0;
        const selectedCount = Array.isArray(userAnswer.answer) ? userAnswer.answer.length : 0;
        const isMultiChoice = neededCount > 1; 
        if (isMultiChoice && selectedCount === neededCount && selectedCount > 0) {
          // Delay ƒë·ªÉ ƒë·∫£m b·∫£o DOM ƒë√£ c·∫≠p nh·∫≠t xong
          setTimeout(() => focusNextOrSubmit(), 100);
        }
      } catch(_) {}
    }

    function toggleFlag() {
      if (isPaused) return;
      userAnswers[currentQuestionIndex].flagged = !userAnswers[currentQuestionIndex].flagged;
      updateFlagButton();
      saveProgress();
    }



    // Statistics and wrong answers tracking
    async function saveWrongAnswers() {
      const wrongAnswers = [];
      const correctAnswers = [];
      
      userAnswers.forEach((userAnswer, index) => {
        const question = questions[index];
        const answerData = {
          questionIndex: index,
          question: question.question,
          options: question.options,
          optionLabels: question.optionLabels,
          correctAnswer: question.answer,
          userAnswer: userAnswer.answer,
          explanation: question.explain || '',
          topicId: topicId,
          topicName: topic.name,
          timestamp: new Date().toISOString()
        };
        
        const answered = Array.isArray(userAnswer.answer) ? userAnswer.answer.length > 0 : !!userAnswer.answer;
        if (answered && !userAnswer.correct) {
          wrongAnswers.push(answerData);
        } else if (answered && userAnswer.correct) {
          correctAnswers.push(answerData);
        }
      });
      
      // Save wrong answers to IndexedDB
      if (wrongAnswers.length > 0) {
        await quizStorage.addWrongAnswers(wrongAnswers);
      }
      
      // Get user info from modal - l∆∞u ch√≠nh x√°c gi√° tr·ªã ƒë√£ nh·∫≠p
      const fullname = userFullnameInput ? userFullnameInput.value.trim() : '';
      const branch = userBranchInput ? userBranchInput.value.trim() : '';
      
      // N·∫øu kh√¥ng nh·∫≠p g√¨ th√¨ d√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh
      const finalFullname = fullname || 'Ng∆∞·ªùi d√πng ·∫©n danh';
      const finalBranch = branch || 'Kh√¥ng x√°c ƒë·ªãnh';
      
      // Save session statistics
      const sessionStats = {
        topicId: topicId,
        topicName: topic.name,
        timestamp: new Date().toISOString(),
        totalQuestions: questions.length,
        correctAnswers: correctAnswers.length,
        wrongAnswers: wrongAnswers.length,
        score: Math.round((correctAnswers.length / questions.length) * 100),
        isExam: topic.isExam === true,
        fullname: finalFullname,
        branch: finalBranch
      };
      await quizStorage.addStatistic(sessionStats);
      
      console.log('Saved statistics:', sessionStats);
      console.log('Wrong answers saved:', wrongAnswers.length);
      
      // G·ª≠i d·ªØ li·ªáu l√™n Google Sheets n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh
      if (window.QUIZ_CONFIG && window.QUIZ_CONFIG.ENABLE_CLOUD_SYNC && window.isConfigured()) {
        sendToGoogleSheets(sessionStats, wrongAnswers);
      }
    }
    
    async function getWrongAnswersByTopic(topicId) {
      const allWrongAnswers = await window.db.getWrongAnswers();
      return allWrongAnswers.filter(answer => answer.topicId === topicId);
    }
    
    
    // G·ª≠i d·ªØ li·ªáu l√™n Google Sheets
    async function sendToGoogleSheets(sessionStats, wrongAnswers) {
      try {
        // T·∫°o user ID duy nh·∫•t (ho·∫∑c l·∫•y t·ª´ localStorage)
        let userId = localStorage.getItem('quiz_user_id');
        if (!userId) {
          userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('quiz_user_id', userId);
        }
        
        // Chu·∫©n b·ªã d·ªØ li·ªáu c√¢u sai v·ªõi ƒë·∫ßy ƒë·ªß ƒë√°p √°n A, B, C, D
        const wrongAnswersList = wrongAnswers.map(answer => {
          const optionsMap = {};
          (answer.optionLabels || []).forEach((label, i) => {
            optionsMap[label] = answer.options[i] || '';
          });
          
          return {
            question: answer.question,
            optionA: optionsMap['A'] || '',
            optionB: optionsMap['B'] || '',
            optionC: optionsMap['C'] || '',
            optionD: optionsMap['D'] || '',
            userAnswer: answer.userAnswer,
            correctAnswer: answer.correctAnswer,
            explanation: answer.explanation
          };
        });
        
        const data = {
          action: 'submitQuiz',
          userId: userId,
          topicId: sessionStats.topicId,
          topicName: sessionStats.topicName,
          isExam: sessionStats.isExam,
          totalQuestions: sessionStats.totalQuestions,
          correctAnswers: sessionStats.correctAnswers,
          wrongAnswers: sessionStats.wrongAnswers,
          score: sessionStats.score,
          duration: 0, // C√≥ th·ªÉ th√™m tracking th·ªùi gian sau
          wrongAnswersList: wrongAnswersList,
          userAgent: navigator.userAgent,
          fullname: sessionStats.fullname,
          branch: sessionStats.branch
        };
        
        
        const response = await fetch(window.QUIZ_CONFIG.GOOGLE_SCRIPT_URL, {
          method: 'POST',
          mode: 'no-cors', // Important for Google Apps Script
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
        
        console.log('Data sent to Google Sheets successfully');
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        showNotification('‚úì ƒê√£ g·ª≠i k·∫øt qu·∫£ l√™n h·ªá th·ªëng th·ªëng k√™', 'success');
        
      } catch (error) {
        console.error('Error sending data to Google Sheets:', error);
        showNotification('‚ö† Kh√¥ng th·ªÉ g·ª≠i d·ªØ li·ªáu l√™n h·ªá th·ªëng', 'warning');
      }
    }
    
    // Hi·ªÉn th·ªã th√¥ng b√°o
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4caf50' : type === 'warning' ? '#ff9800' : '#2196f3'};
        color: white;
        padding: 16px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 10002;
        font-size: 14px;
        font-weight: 500;
        animation: slideIn 0.3s ease-out;
      `;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    function submitQuiz() {
      if (quizSubmitted) return;
      
      // T√≠nh ƒëi·ªÉm s·ªë tr∆∞·ªõc khi hi·ªÉn th·ªã modal
      const correctCount = userAnswers.filter(a => a.correct).length;
      const totalQuestions = questions.length;
      const score = Math.round((correctCount / totalQuestions) * 100);
      
      // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ƒëi·ªÉm s·ªë trong modal
      const previewCorrect = document.getElementById('preview-correct');
      const previewTotal = document.getElementById('preview-total');
      const previewPercentage = document.getElementById('preview-percentage');
      
      if (previewCorrect) previewCorrect.textContent = correctCount;
      if (previewTotal) previewTotal.textContent = totalQuestions;
      if (previewPercentage) previewPercentage.textContent = score;
      
      // Hi·ªÉn th·ªã modal nh·∫≠p th√¥ng tin ng∆∞·ªùi d√πng
      userInfoModal.classList.remove('hidden');
      
      // Focus v√†o tr∆∞·ªùng h·ªç t√™n
      setTimeout(() => {
        if (userFullnameInput) {
          userFullnameInput.focus();
        }
      }, 100);
    }

    async function confirmSubmitQuiz() {
      if (quizSubmitted) return;
      
      // ƒê√≥ng modal (kh√¥ng c·∫ßn ki·ªÉm tra b·∫Øt bu·ªôc n·ªØa)
      userInfoModal.classList.add('hidden');
      
      // N·ªôp b√†i
      quizSubmitted = true;
      showResults();
      await saveProgress();
      await saveWrongAnswers();
      // clear timer keys
      await quizStorage.deleteTimerEnd(topicId);
    }
function getAnswerStatus(index){
  const ua = userAnswers?.[index];
  const answered = !ua ? false : (Array.isArray(ua.answer) ? ua.answer.length > 0 : ua.answer != null);
  if (!answered) return { text: "Ch∆∞a ch·ªçn", cls: "status-pending" };
  return ua.correct ? { text: "ƒê√É CH·ªåN: ƒê√öNG", cls: "status-correct" }
                    : { text: "ƒê√É CH·ªåN: SAI",  cls: "status-incorrect" };
}

function updateNextBtnStatus(){
  const el = document.getElementById('next-btn') || (typeof nextBtn !== 'undefined' ? nextBtn : null);
  if (!el) return;
  const st = getAnswerStatus(currentQuestionIndex);
  const base = `C√¢u ti·∫øp <i class="material-icons">navigate_next</i>`;
  el.innerHTML = `${base} <span class="status-badge ${st.cls}">${st.text}</span>`;
}

function focusNextOrSubmit(){
  try {
    const byId = id => document.getElementById(id);
    const isHidden = el => !el || el.offsetParent === null || getComputedStyle(el).display === 'none';
    const isDisabled = el => !el || el.disabled === true;
    const isLast = (typeof questions !== 'undefined' && Array.isArray(questions))
      ? currentQuestionIndex === questions.length - 1
      : false;

    // Always resolve fresh elements from DOM
    let nextEl = byId('next-btn');
    let submitEl = byId('submit-quiz-btn');

    console.log('focusNextOrSubmit called:', { isLast, nextEl, submitEl, nextHidden: isHidden(nextEl), nextDisabled: isDisabled(nextEl) });

    // Decide preferred target
    let target = null;
    if (isLast || isHidden(nextEl) || isDisabled(nextEl)) {
      target = submitEl;
    } else {
      target = nextEl;
    }
    
    console.log('Focus target:', target);
    if (!target) {
      console.warn('No focus target found!');
      return;
    }

    const doFocus = () => {
      if (typeof target.focus === 'function') {
        console.log('Focusing:', target.id || target);
        try { 
          // Cu·ªôn n√∫t v√†o t·∫ßm nh√¨n tr∆∞·ªõc
          target.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Sau ƒë√≥ focus (kh√¥ng cu·ªôn th√™m)
          setTimeout(() => {
            target.focus({ preventScroll: true }); 
            console.log('Focus successful, activeElement:', document.activeElement);
          }, 200);
        } catch (_) { 
          target.focus(); 
          console.log('Focus fallback, activeElement:', document.activeElement);
        }
      }
    };

    // Execute focus immediately and with fallback
    doFocus();
    setTimeout(doFocus, 50);
  } catch (e) {
    console.error('focusNextOrSubmit error:', e);
  }
}

    function showResults() {
      const correctCount = userAnswers.filter(a => a.correct).length;
      const totalQuestions = questions.length;
      const score = Math.round((correctCount / totalQuestions) * 100);
      
      resultArea.innerHTML = `
        <div class="result-container">
          <div class="result-header">
          <h2>K·∫øt qu·∫£ b√†i ki·ªÉm tra</h2>
            <button id="close-result-btn" class="close-btn">&times;</button>
          </div>
          <div class="score-display">
            <div class="score">${correctCount}<span>/${totalQuestions}</span></div>
            <div class="percentage">${score}%</div>
          </div>
          
          <div class="result-form">
            <div class="form-group">
              <label style="font-size: 1.1rem; font-weight: 600; color: var(--primary-color); margin-bottom: 12px; display: block;">Th√¥ng tin ng∆∞·ªùi l√†m b√†i:</label>
              <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 20px; border-radius: 12px; border: 1px solid rgba(128, 0, 32, 0.1); box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                <div style="margin-bottom: 12px; font-size: 1rem;">
                  <strong style="color: var(--primary-color);">H·ªç t√™n:</strong> 
                  <span id="result-fullname" style="color: #333; margin-left: 8px;">-</span>
                </div>
                <div style="font-size: 1rem;">
                  <strong style="color: var(--primary-color);">ƒê∆°n v·ªã:</strong> 
                  <span id="result-branch" style="color: #333; margin-left: 8px;">-</span>
                </div>
              </div>
            </div>
          </div>
          
          <div class="result-actions">
            <div class="result-actions-grid">
              <a href="index.html" class="btn result-btn primary">
                <i class="material-icons">home</i> V·ªÅ trang ch·ªß
              </a>
              <button id="restart-btn" class="btn btn-outline result-btn">
                <i class="material-icons">refresh</i> L√†m l·∫°i
              </button>
              <button id="wrong-answers-btn" class="btn btn-outline result-btn">
                <i class="material-icons">error_outline</i> C√¢u sai
              </button>
              <button id="leaderboard-btn" class="btn btn-outline result-btn">
                <i class="material-icons">leaderboard</i> B·∫£ng x·∫øp h·∫°ng
              </button>
            </div>
          </div>
        </div>
      `;
      resultArea.style.display = 'block';
      
      // Hi·ªÉn th·ªã th√¥ng tin ng∆∞·ªùi d√πng
      const resultFullnameEl = document.getElementById('result-fullname');
      const resultBranchEl = document.getElementById('result-branch');
      if (resultFullnameEl && userFullnameInput) {
        const fullname = userFullnameInput.value.trim();
        resultFullnameEl.textContent = fullname || 'Ng∆∞·ªùi d√πng ·∫©n danh';
      }
      if (resultBranchEl && userBranchInput) {
        const branch = userBranchInput.value.trim();
        resultBranchEl.textContent = branch || 'Kh√¥ng x√°c ƒë·ªãnh';
      }
      
      // Attach event handlers once results are shown
      const restartBtn = document.getElementById('restart-btn');
      const wrongAnswersBtn = document.getElementById('wrong-answers-btn');
      const leaderboardBtn = document.getElementById('leaderboard-btn');
      const closeResultBtn = document.getElementById('close-result-btn');
      
      if (closeResultBtn) {
        closeResultBtn.addEventListener('click', () => {
          resultArea.style.display = 'none';
        });
      }
      
      if (restartBtn) {
        restartBtn.addEventListener('click', async () => {
          // Clear quiz progress and reset state to the very beginning
          await quizStorage.deleteProgress(topicId);
          // Reset timer end and start fresh if timed
          await quizStorage.deleteTimerEnd(topicId);
          // For exams: clear cached selection so a new random set is built
          await quizStorage.deleteExamQuestions(topicId);
          quizSubmitted = false;
          // Rebuild questions for exams; otherwise reuse topic.questions
          if (topic.isExam === true && topic.examConfig && Array.isArray(topic.examConfig.distribution)) {
            questions = await getOrCreateExamSessionQuestions(topic);
          }
          // Shuffle order and options for a new attempt
          shuffleQuestionsAndOptions();
          userAnswers = questions.map(() => ({
            answer: null,
            correct: null,
            flagged: false,
            explanationShown: false
          }));
          currentQuestionIndex = 0;
          resultArea.innerHTML = '';
          resultArea.style.display = 'none';
          showQuestion(0);
          updateFlagButton(); // Update flag button visibility
          saveProgress();
          const ef = getEffectiveDurationMinutes();
          if (ef > 0) {
            startOrResumeTimer(ef);
          }
        }, { once: true });
      }
      
      // Wrong answers button handler
      if (wrongAnswersBtn) {
        wrongAnswersBtn.addEventListener('click', () => {
          showWrongAnswers();
        });
      }
      
      // Leaderboard button handler
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', () => {
          showLeaderboard();
        });
      }
      
      // Show all explanations for review
      questions.forEach((q, index) => {
        if (q.explain) {
          userAnswers[index].explanationShown = true;
        }
      });
      
      // Show first question with explanations
      showQuestion(0);
    }

    
    async function showLeaderboard() {
      // Remove any existing leaderboard modal
      const existingModal = document.querySelector('.leaderboard-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const allStats = await window.db.getStatisticsByTopic(topicId) || [];
      const topicStats = allStats;
      
      // Sort by score descending, then by timestamp (newest first for same score)
      const sortedStats = topicStats.sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score;
        }
        return new Date(b.timestamp) - new Date(a.timestamp);
      });
      
      // Create leaderboard modal
      const modal = document.createElement('div');
      modal.className = 'modal leaderboard-modal';
      modal.innerHTML = `
        <div style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: white;
          z-index: 10000;
          overflow-y: auto;
          padding: 20px;
        ">
          <!-- Header -->
          <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
          ">
            <h2 style="color: #800020; margin: 0; font-size: 28px;">
              üèÜ B·∫£ng x·∫øp h·∫°ng - ${topic.name}
            </h2>
            <button onclick="this.closest('.leaderboard-modal').remove()" style="
              background: #c62828;
              color: white;
              border: none;
              border-radius: 50%;
              width: 40px;
              height: 40px;
              cursor: pointer;
              font-size: 20px;
              display: flex;
              align-items: center;
              justify-content: center;
            ">√ó</button>
          </div>
          
          <!-- Statistics Summary -->
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 30px;">
            <div style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
              <div style="font-size: 32px; font-weight: bold; color: #1976d2; margin-bottom: 8px;">${sortedStats.length}</div>
              <div style="color: #666; font-size: 14px; font-weight: 500;">T·ªïng s·ªë l·∫ßn l√†m b√†i</div>
            </div>
            <div style="background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c8 100%); padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
              <div style="font-size: 32px; font-weight: bold; color: #2e7d32; margin-bottom: 8px;">${sortedStats.length > 0 ? Math.round(sortedStats.reduce((sum, s) => sum + s.score, 0) / sortedStats.length) : 0}%</div>
              <div style="color: #666; font-size: 14px; font-weight: 500;">ƒêi·ªÉm trung b√¨nh</div>
            </div>
            <div style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
              <div style="font-size: 32px; font-weight: bold; color: #f57c00; margin-bottom: 8px;">${sortedStats.length > 0 ? Math.max(...sortedStats.map(s => s.score)) : 0}%</div>
              <div style="color: #666; font-size: 14px; font-weight: 500;">ƒêi·ªÉm cao nh·∫•t</div>
            </div>
          </div>
          
          <!-- Leaderboard -->
          <div style="max-height: 60vh; overflow-y: auto;">
            ${sortedStats.length > 0 ? sortedStats.map((stat, index) => {
              const rank = index + 1;
              const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
              
              return `
                <div style="
                  background: ${rank <= 3 ? 'linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%)' : 'white'};
                  border: ${rank <= 3 ? '2px solid #ff9800' : '1px solid #e0e0e0'};
                  border-radius: 12px;
                  padding: 20px;
                  margin-bottom: 16px;
                  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                ">
                  <div style="display: flex; align-items: center; gap: 16px;">
                    <div style="
                      font-size: 24px;
                      font-weight: bold;
                      color: ${rank <= 3 ? '#ff9800' : '#666'};
                      min-width: 40px;
                    ">${medal}</div>
                    <div>
                      <div style="font-size: 16px; color: #333; font-weight: 500;">
                        ${stat.fullname || 'Ng∆∞·ªùi d√πng ·∫©n danh'}
                    </div>
                      <div style="font-size: 14px; color: #666;">
                        ${stat.branch || 'Kh√¥ng x√°c ƒë·ªãnh'} ‚Ä¢ ${new Date(stat.timestamp).toLocaleString('vi-VN')}
                    </div>
                  </div>
                  </div>
                  <div style="text-align: right;">
                    <div style="
                      font-size: 24px;
                      font-weight: bold;
                      color: ${stat.score >= 80 ? '#2e7d32' : stat.score >= 60 ? '#f57c00' : '#c62828'};
                    ">${stat.score}%</div>
                  <div style="font-size: 14px; color: #666;">
                      ${stat.correctAnswers}/${stat.totalQuestions} c√¢u ƒë√∫ng
                  </div>
                </div>
            </div>
              `;
            }).join('') : `
              <div style="text-align: center; padding: 60px 20px; color: #999;">
                <i class="material-icons" style="font-size: 72px; margin-bottom: 16px; opacity: 0.5;">emoji_events</i>
                <p style="font-size: 18px; font-weight: 500;">Ch∆∞a c√≥ d·ªØ li·ªáu</p>
                <p>H√£y l√†m b√†i ƒë·ªÉ xu·∫•t hi·ªán tr√™n b·∫£ng x·∫øp h·∫°ng!</p>
              </div>
            `}
          </div>
          
          <!-- Action Buttons -->
          <div style="display: flex; gap: 16px; justify-content: center; padding: 30px 0; border-top: 2px solid #e0e0e0; flex-wrap: wrap;">
            <button onclick="this.closest('.leaderboard-modal').remove()" class="btn btn-outline" style="padding: 12px 24px; font-size: 16px;">
              <i class="material-icons">close</i> ƒê√≥ng
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    async function showWrongAnswers() {
      // Remove any existing wrong answers modal
      const existingModal = document.querySelector('.wrong-answers-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const wrongAnswers = await getWrongAnswersByTopic(topicId);
      
      if (wrongAnswers.length === 0) {
        alert('B·∫°n ch∆∞a c√≥ c√¢u tr·∫£ l·ªùi sai n√†o trong chuy√™n ƒë·ªÅ n√†y! üéâ');
        return;
      }
      
      // Create full-screen wrong answers page
      const modal = document.createElement('div');
      modal.className = 'modal wrong-answers-modal';
      modal.innerHTML = `
        <div style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: white;
          z-index: 10000;
          overflow-y: auto;
          padding: 20px;
        ">
          <!-- Header -->
          <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
          ">
            <h2 style="color: #800020; margin: 0; font-size: 28px;">
              ‚ùå C√¢u tr·∫£ l·ªùi sai - ${topic.name}
            </h2>
            <div style="display: flex; align-items: center; gap: 16px;">
              <span style="background: #ffebee; color: #c62828; padding: 8px 16px; border-radius: 20px; font-weight: 600;">
                T·ªïng c·ªông: ${wrongAnswers.length} c√¢u sai
              </span>
              <button onclick="this.closest('.wrong-answers-modal').remove()" style="
                background: #c62828;
                color: white;
                border: none;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                cursor: pointer;
                font-size: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
              ">√ó</button>
            </div>
          </div>
          
          <!-- Wrong Answers List -->
          <div style="display: grid; gap: 20px; margin-bottom: 40px;">
            ${wrongAnswers.map((answer, index) => `
              <div style="background: white; border: 2px solid #ffcdd2; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                  <div style="font-weight: bold; color: #c62828; font-size: 20px;">
                    C√¢u ${index + 1}
                  </div>
                  <div style="font-size: 12px; color: #999;">
                    ${new Date(answer.timestamp).toLocaleString('vi-VN')}
                  </div>
                </div>
                
                <div style="margin-bottom: 16px; line-height: 1.6; font-size: 16px; color: #333;">
                  ${answer.question}
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                  <div style="background: #ffebee; padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; color: #c62828; margin-bottom: 4px;">ƒê√°p √°n c·ªßa b·∫°n:</div>
                    <div style="font-size: 18px; font-weight: bold; color: #c62828;">${answer.userAnswer}</div>
                  </div>
                  <div style="background: #e8f5e8; padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; color: #2e7d32; margin-bottom: 4px;">ƒê√°p √°n ƒë√∫ng:</div>
                    <div style="font-size: 18px; font-weight: bold; color: #2e7d32;">${answer.correctAnswer}</div>
                  </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin-bottom: 12px;">
                  <div style="font-weight: 600; margin-bottom: 8px; color: #333;">C√°c l·ª±a ch·ªçn:</div>
                  ${answer.options.map((option, i) => `
                    <div style="padding: 4px 0; color: #666; ${answer.optionLabels[i] === answer.correctAnswer ? 'font-weight: bold; color: #2e7d32;' : answer.optionLabels[i] === answer.userAnswer ? 'font-weight: bold; color: #c62828;' : ''}">
                      ${answer.optionLabels[i]}. ${option}
                    </div>
                  `).join('')}
                </div>
                
                ${answer.explanation ? `
                  <div style="background: #e3f2fd; padding: 16px; border-radius: 8px; margin-top: 12px;">
                    <div style="font-weight: 600; color: #1976d2; margin-bottom: 8px;">üí° Gi·∫£i th√≠ch:</div>
                    <div style="color: #333; line-height: 1.6;">${answer.explanation}</div>
                  </div>
                ` : ''}
              </div>
            `).join('')}
          </div>
          
          <!-- Action Buttons -->
          <div style="display: flex; gap: 16px; justify-content: center; padding: 30px 0; border-top: 2px solid #e0e0e0;">
            <button onclick="exportWrongAnswersExcel('${topicId}')" class="btn" style="display: inline-flex; align-items: center; gap: 8px; padding: 12px 24px; font-size: 16px;">
              <i class="material-icons">download</i> Xu·∫•t Excel (.xlsx)
            </button>
            <button onclick="exportWrongAnswers('${topicId}')" class="btn btn-outline" style="display: inline-flex; align-items: center; gap: 8px; padding: 12px 24px; font-size: 16px;">
              <i class="material-icons">description</i> Xu·∫•t CSV
            </button>
            <button onclick="this.closest('.wrong-answers-modal').remove()" class="btn btn-outline" style="padding: 12px 24px; font-size: 16px;">
              <i class="material-icons">close</i> ƒê√≥ng
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }

    function initEventListeners() {
      // Navigation
      prevBtn.addEventListener('click', async () => {
        if (isPaused) return;
        if (currentQuestionIndex > 0) {
          window.suppressFocusUntilMs = 0;
          window.forceFocusButtonOnce = false;
          showQuestion(currentQuestionIndex - 1);
          await saveProgress();
          updateNextBtnStatus();
        }
      });

      nextBtn.addEventListener('click', async () => {
        if (isPaused) return;
        if (currentQuestionIndex < questions.length - 1) {
          window.suppressFocusUntilMs = 0;
          window.forceFocusButtonOnce = false;
          showQuestion(currentQuestionIndex + 1);
          await saveProgress();
          updateNextBtnStatus();
        }
      });

      // Submit quiz
      submitBtn.addEventListener('click', submitQuiz);
      
      // Flag question
      flagBtn.addEventListener('click', toggleFlag);
      
      // Session modal close button
      if (closeSessionModal) {
        closeSessionModal.addEventListener('click', () => {
          sessionModal.classList.add('hidden');
        });
      }
      
      // User info modal event listeners
      if (closeUserInfoModal) {
        closeUserInfoModal.addEventListener('click', () => {
          userInfoModal.classList.add('hidden');
        });
      }
      
      if (cancelSubmitBtn) {
        cancelSubmitBtn.addEventListener('click', () => {
          userInfoModal.classList.add('hidden');
        });
      }
      
      if (confirmSubmitBtn) {
        confirmSubmitBtn.addEventListener('click', confirmSubmitQuiz);
      }
      
      // Allow Enter key to submit form
      if (userInfoForm) {
        userInfoForm.addEventListener('submit', (e) => {
          e.preventDefault();
          confirmSubmitQuiz();
        });
      }
      
      // Sidebar toggle functionality
      if (sidebarToggleBtn) {
        sidebarToggleBtn.addEventListener('click', () => {
          questionSidebar.classList.add('open');
          sidebarToggleBtn.classList.add('hidden');
        });
      }
      
      if (toggleSidebarBtn) {
        toggleSidebarBtn.addEventListener('click', () => {
          questionSidebar.classList.remove('open');
          sidebarToggleBtn.classList.remove('hidden');
        });
      }
      
      // Close sidebar when clicking outside
      questionSidebar.addEventListener('click', (e) => {
        if (e.target === questionSidebar) {
          questionSidebar.classList.remove('open');
          sidebarToggleBtn.classList.remove('hidden');
        }
      });
      
      
      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (isPaused) return;
        if (e.key === 'ArrowLeft' && currentQuestionIndex > 0) {
          window.suppressFocusUntilMs = 0;
          window.forceFocusButtonOnce = false;
          showQuestion(currentQuestionIndex - 1);
        } else if (e.key === 'ArrowRight' && currentQuestionIndex < questions.length - 1) {
          window.suppressFocusUntilMs = 0;
          window.forceFocusButtonOnce = false;
          showQuestion(currentQuestionIndex + 1);
        } else if (e.key === ' ' || e.key === 'Enter') {
          if (!e.target.matches('button, a, input, textarea')) {
            e.preventDefault();
            const selected = document.querySelector('.answer:not(.selected)');
            if (selected) selected.click();
          }
        } else if (e.key === 'f' || e.key === 'F') {
          e.preventDefault();
          toggleFlag();
        } else if (e.key === 'Escape') {
          reviewPanel.classList.remove('show');
          document.body.style.overflow = 'auto';
        }
      });
    }

    function getTopicId() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('topic');
    }

    function showError(message) {
      document.body.innerHTML = `
        <div class="error-message">
          <h2>${message}</h2>
          <p>Vui l√≤ng quay l·∫°i trang ch·ªß v√† th·ª≠ l·∫°i.</p>
          <a href="index.html" class="btn">
            <i class="material-icons">home</i> V·ªÅ trang ch·ªß
          </a>
        </div>
      `;
    }


    window.exportWrongAnswersExcel = async function(topicId) {
      const wrongAnswers = await getWrongAnswersByTopic(topicId);
      
      if (wrongAnswers.length === 0) {
        alert('Kh√¥ng c√≥ c√¢u tr·∫£ l·ªùi sai n√†o ƒë·ªÉ xu·∫•t!');
        return;
      }
      
      // Create workbook
      const wb = XLSX.utils.book_new();
      
      // Wrong answers sheet with all options displayed
      const wrongAnswersData = [
        ['C√¢u tr·∫£ l·ªùi sai chi ti·∫øt - ' + topic.name, '', '', '', '', '', '', ''],
        ['STT', 'C√¢u h·ªèi', 'ƒê√°p √°n A', 'ƒê√°p √°n B', 'ƒê√°p √°n C', 'ƒê√°p √°n D', 'ƒê√°p √°n c·ªßa b·∫°n', 'ƒê√°p √°n ƒë√∫ng', 'Gi·∫£i th√≠ch', 'Th·ªùi gian']
      ];
      
      wrongAnswers.forEach((answer, index) => {
        // Map option labels to their text values
        const optionsMap = {};
        (answer.optionLabels || []).forEach((label, i) => {
          optionsMap[label] = answer.options[i] || '';
        });
        
        wrongAnswersData.push([
          index + 1,
          answer.question,
          optionsMap['A'] || '',
          optionsMap['B'] || '',
          optionsMap['C'] || '',
          optionsMap['D'] || '',
          answer.userAnswer,
          answer.correctAnswer,
          answer.explanation || '',
          new Date(answer.timestamp).toLocaleString('vi-VN')
        ]);
      });
      
      const ws = XLSX.utils.aoa_to_sheet(wrongAnswersData);
      ws['!cols'] = [
        { width: 6 },   // STT
        { width: 60 },  // C√¢u h·ªèi
        { width: 30 },  // ƒê√°p √°n A
        { width: 30 },  // ƒê√°p √°n B
        { width: 30 },  // ƒê√°p √°n C
        { width: 30 },  // ƒê√°p √°n D
        { width: 15 },  // ƒê√°p √°n c·ªßa b·∫°n
        { width: 15 },  // ƒê√°p √°n ƒë√∫ng
        { width: 40 },  // Gi·∫£i th√≠ch
        { width: 20 }   // Th·ªùi gian
      ];
      XLSX.utils.book_append_sheet(wb, ws, 'C√¢u sai');
      
      // Save file
      const fileName = `cau-sai-${topic.name.replace(/[^a-zA-Z0-9]/g, '-')}-${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(wb, fileName);
    };

    
    window.exportWrongAnswers = async function(topicId) {
      const wrongAnswers = await getWrongAnswersByTopic(topicId);
      
      if (wrongAnswers.length === 0) {
        alert('Kh√¥ng c√≥ c√¢u tr·∫£ l·ªùi sai n√†o ƒë·ªÉ xu·∫•t!');
        return;
      }
      
      // Create CSV content
      let csvContent = 'C√¢u tr·∫£ l·ªùi sai - ' + topic.name + '\n\n';
      csvContent += 'STT,C√¢u h·ªèi,ƒê√°p √°n c·ªßa b·∫°n,ƒê√°p √°n ƒë√∫ng,Gi·∫£i th√≠ch,Th·ªùi gian\n';
      
      wrongAnswers.forEach((answer, index) => {
        csvContent += (index + 1) + ',"' + 
                     answer.question.replace(/"/g, '""') + '","' + 
                     answer.userAnswer + '","' + 
                     answer.correctAnswer + '","' + 
                     (answer.explanation || '').replace(/"/g, '""') + '","' + 
                     new Date(answer.timestamp).toLocaleString('vi-VN') + '"\n';
      });
      
      // Download file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `cau-sai-${topic.name.replace(/[^a-zA-Z0-9]/g, '-')}-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };

    

    // Initialize the quiz when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initQuiz);
              } else {
      initQuiz();
    }
  </script>
  <footer style="background: linear-gradient(135deg, #8e0e00 0%, #1f1c18 100%); color: #fff; padding: 15px 15px 10px; margin-top: 30px; position: relative; overflow: hidden;">
    <div style="max-width: 1200px; margin: 0 auto; position: relative; z-index: 1;">
      <div style="display: flex; justify-content: space-between; flex-wrap: wrap; gap: 20px; margin-bottom: 12px;">
        <div style="flex: 1; min-width: 250px;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
            <div style="width: 35px !important; height: 35px !important; background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%) !important; border-radius: 8px !important; padding: 2px !important; border: 2px solid rgba(255,255,255,0.9) !important; box-shadow: 0 3px 8px rgba(0,0,0,0.15), 0 1px 3px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.8) !important; display: flex !important; align-items: center !important; justify-content: center !important; transition: all 0.3s ease !important; position: relative !important; overflow: hidden !important;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2), 0 2px 6px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.9)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px rgba(0,0,0,0.15), 0 1px 3px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.8)'">
              <img src="logo-new.png?v=20250112" alt="Logo Agribank" style="width: 100% !important; height: 100% !important; object-fit: contain !important; filter: none !important; -webkit-filter: none !important; -moz-filter: none !important; -ms-filter: none !important; -o-filter: none !important; transition: all 0.3s ease !important;" onerror="console.error('Logo load failed:', this.src); this.style.display='none';">
            </div>
            <div>
              <h3 style="font-size: 0.9em; margin: 0 0 2px; color: #fff; font-weight: 600;">H·ªá th·ªëng √¥n luy·ªán tr·∫Øc nghi·ªám</h3>
              <p style="margin: 0; color: rgba(255, 255, 255, 0.8); font-size: 0.75em;">Chi nh√°nh C·∫ßn Th∆° II</p>
            </div>
          </div>
          <p style="color: rgba(255, 255, 255, 0.7); line-height: 1.4; margin: 0; font-size: 0.8em;">
            H·ªá th·ªëng h·ªó tr·ª£ h·ªçc t·∫≠p v√† ƒë√°nh gi√° ki·∫øn th·ª©c tr·ª±c tuy·∫øn.
          </p>
        </div>
        
        <div style="background: rgba(255, 255, 255, 0.05); padding: 6px; border-radius: 6px; min-width: 250px; backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.1);">
          <h4 style="color: #fff; margin: 0 0 3px 0; font-size: 0.86em; padding-bottom: 2px; border-bottom: 2px solid #800020; display: inline-block;">Li√™n h·ªá h·ªó tr·ª£</h4>
          <div style="color: rgba(255, 255, 255, 0.9); padding: 0; font-size: 0.74em; line-height: 1.4; margin: 0;">
            <div style="margin: 0; padding: 0;">üë§ Nguy·ªÖn Th√†nh Trung</div>
            <div style="margin: 0; padding: 0;">üìû 0947.86.86.82</div>
            <div style="margin: 0; padding: 0;">‚úâÔ∏è trungnguyenthanh1@agribank.com.vn</div>
            <div style="margin: 0; padding: 0;">üè¶ Agribank Chi nh√°nh C·∫ßn Th∆° II</div>
          </div>
        </div>
      </div>
      
      <div style="text-align: center; padding-top: 8px; margin-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1); color: rgba(255, 255, 255, 0.6); font-size: 0.7em;">
        <strong>¬© 2025 H·ªá th·ªëng √¥n luy·ªán tr·∫Øc nghi·ªám C·∫ßn Th∆° II</strong>
      </div>
    </div>
    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: #800020;"></div>
  </footer>
  <script src="mobile-touch.js"></script>
</body>
</html>

